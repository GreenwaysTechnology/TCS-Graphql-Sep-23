 			  Graphql API Implementation
.....................................................................................
In order to build apis we have many technologies

1.REST
2.Graphql
3.Grpc

How to build REST apis?

  Restfull webservices are built based on "Resources" in the Problem Domain.

Resources are represented by "Object" which expose Data.

Eg:
 CustomerResource,OrderResource,PaymentResource,CourseResource

Resources are identified by "URL" 
  => /api/customers GET | POST | DELETE | UPDATE

In Graphql apps are built based on "Models" Which are objects

What ever language we have to think in terms of Objects
...................................................................................
Graphql Schema Language                         Programming Langauge
....................................................................................
  Schema                                        class or Object

  Customer                                      class Customer {} | let Customer={}

Object shape is described by "Schema". 

Schema is nothing but "Plan"

In Graphql context, the "Problem domain"  is represented by "Schema language"
....................................................................................
			SDL - Schema Definition Language
....................................................................................

SDL Core concepts:
..................

1.Type System:
...............
   The Type system defines the platform and language independant data types which describe what data can be quried by client.


Schema Type Systems =============================>Programming language Type System
eg:
   String           =============================>javascript -string

    Int             ==============================>javascript -number

Client                                        Server

 Query ----|SDL-----send request --------    |SDL---Models--->Bizlogic(services|							 resolvers)-->Datasources

					  |---->java,kotlin,scala,c#,python -jvm
					  |---->js,typescript -node
			SDL implementation|---->
					  |---->
					
	
How to start with SDL?

we need to define type.

syntax:
 type TypeName{
    field:Type
 }

IN SDL, there is root type, every type is dervied from the root type.

type Schema {
  query:Query
  mutation:Mutation
  subscription:Subscription
}

type Query{}

type Mutation{}

type Subscription{}

type User {
 id:Int
 firstName:String
 lastName:String
 status:Boolean
 points:Float
}

type Query { 
 #apis
 user:User
}

Client side 

query {
 user {
  id
  status
 }
}


type Mutation { 
 #apis
 createUser(user:User):User
 updateUser(id:ID,user:User):User
}

mutation CreateUser($user:User) {
  createUser(user:$user){
    id
    status
  }

}
....................................................................................
				 Data types In SDL
.....................................................................................

1.Scallar Types
   Scallar are like primitives types in the programming languages

1.Int - 32 Bit Signed Integer
2.String - UTF-8 
3.Boolean - true or false
4.Float - Signed Double
5.ID - String but Serialized string - For unique identification

2.Custom Types/Reference Types/ Object types
 Similar to classes in object oriented languages like java,C++,C#

type User {
 id:Int
 firstName:String
 lastName:String
 status:Boolean
 points:Float
}

Object can have other Object Type:
..................................
  Like has a relationship / Dependency injection

type Address { 
 city:String
 state:String
 country:String
}

type User {
 id:Int
 firstName:String
 lastName:String
 status:Boolean
 points:Float
 address:Address
}


Client side 

query {
 user {
  id
  status
  address  {
    city
  }
 }
}
....................................................................................
			Handling null and not null values
....................................................................................

Client query with data

query {
  user {
    name    ------------------> response {name:'Subramanian'}
  }
}


Client query without data

query {
  user {
    name    ------------------> response {name:null}
  }
}

Client is expecting that dont want to include null, if server null , i have to throw an exception.
 =>Not null field

Syntax:
   fieldName:Type!

! -Not Null



type Address { 
 city:String
 state:String
 country:String
}

type User {
 id:Int!
 firstName:String!
 lastName:String!
 status:Boolean
 points:Float
 address:Address
}

Here, id ,firstName,lastName cant be null, if there is null value, the server will throw exception.
....................................................................................
				Collections - List of similar values
....................................................................................
The field may have more values

 fieldName:[DataType]

Data Type could be scallar or Object Type

eg:
  products:[Product]
  users:[User]
  skills:[String]
.....................................................................................
				Advanced Types
.....................................................................................

=>Mutation
=>Subscription
=>Input
=>Enum
=>Union
=>Interface


Mutation:
 For Add,update,delete operations

type Mutation {
  createUser(id:ID,firstName:String,lastName:String,age:Int):User
  updatUser(id:ID,user:User):User
  removeUser(id:ID):User
}
...................................................................................
                         Input
...................................................................................
Input type are special object type that allow you to provide hierachial data as args to fields

type Mutation {
  createUser(id:ID,firstName:String,lastName:String,age:Int):User
}

In the above code you can we have passed indivual fields, which is not going to be good.

Can i user type

type User {
 id:ID
 firstName:String
 lastName:String
 age:Int
}
type Mutation {
  createUser(user:User):User
}

Instead of passing User type, graphql offers special object type input

input CreateUserInput {
 id:ID
 firstName:String
 lastName:String
 age:Int
}

type Mutation {
  createUser(user:CreateUserInput):User
}
.....................................................................................
			 Enums
.....................................................................................

An Enum is similar to scalar type, but its leagal values are defined in the schema

enum Gender {
 MALE
 FEMALE
 THIRD
}

type Query {
 gender:Gender
}
.....................................................................................				Union and Interfaces
.....................................................................................
Unions and interfaces are abstract Graphql types that enables a schema field to return one of the multiple object types.

union Media = Image | Video

type Query {
  getMedia:[Media]
}

Note:
  Union type must be only object types not scalar or input types.
....................................................................................
			Interfaces
.....................................................................................

Interface Represents common fields that multiple objects can include

interface Book {
  title:String
  author:String
}
type GraphQLBook implements Book {
  title:String
  author:String 
  X:String  
}

type StoryBook implements Book {
  title:String
  author:String 
  Y:String  
}

Client Side:

Syntax : 1
query GetBooks {
   books {
      author
      title
    }
}
Here it returns all data,

What if i want Graphqlbook and storybook details 

query GetBooks {
  
   __typename
   title
   author
   ....on GraphQLBook {
      X
   }
   ....on StoryBook {
      Y
   }
}
...................................................................................
			   Custom Scalar types
...................................................................................
Graphql provides custom scalar types. 
I want Date,Time

How to define custom scallar?

scalar Date

type User {
  dob:Date
}

Here Date is custom scalar but this data type is represented / logic of this type is provided through "Server side code".
....................................................................................
			 Graphql Application dev
...................................................................................

You can write code in any language.

Java:
1.graphql-java
2.SpringBoot with Graphql
3.DGS Framework-Netflix
etc...

Javascript:

1.graphql-js.js
The JavaScript reference implementation for GraphQL, a query language for APIs created by Facebook.


2.Apollo
  It is platform for building enterprise graphql apps
  The core of Apollo framework is written on the graphql.js and express.js

Graphql application can be built using two arch
 1.monolith arch
 2.Microservices arch.

Apollo Core concepts:
  SuperGraph:
      Collection of small graphs called subgraph
      A unified network of your organizations microservices and their datasources
      -All Composed into a single distributed API.

  SubGraph:
      It represents a single Graph application

  Graph OS:
     It is cloud platform which hosts supergraph and router

   Router :
      It is compostion api , clients will communicate only Router
     Router internally stiches the schema for data reterival.

Components of Apollo:
.....................
1.Apollo Server : node js server written in express.js
2.Schema defintions - SDL
3.Resolvers - Schema Implementations like queries,mutations,subscription
4.Data Sources -  Database,rest api, any other apis.

Apollo code can be written in "javascript or typescript".
.....................................................................................
				Apollo Project setup
....................................................................................

Required Softwares:

1.node.js latest version
2.vscode


Steps:
1.create project folder
E:\session\TCS\GraphQL>mkdir apollo-gettingstarted
2.create package.json file
E:\session\TCS\GraphQL>cd apollo-gettingstarted

E:\session\TCS\GraphQL\apollo-gettingstarted>npm init --yes
Wrote to E:\session\TCS\GraphQL\apollo-gettingstarted\package.json:

{
  "name": "apollo-gettingstarted",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
3.lanuch code window
E:\session\TCS\GraphQL\apollo-gettingstarted>code .
4.create source dir
E:\session\TCS\GraphQL\apollo-gettingstarted>mkdir src

5.install apollo server dependencies

npm install @apollo/server graphql

6.install type script dependencies

npm i --save-dev typescript @types/node

package.json
"dependencies": {
    "@apollo/server": "^4.9.3",
    "graphql": "^16.8.0"
  },
  "devDependencies": {
    "@types/node": "^20.5.7",
    "typescript": "^5.2.2"
  }

7.configure ts config file
tsconfig.json
{
    "compilerOptions": {
        "rootDirs": [
            "src"
        ],
        "outDir": "dist",
        "lib": [
            "ES2020"
        ],
        "target": "ES2020",
        "module": "ESNext",
        "moduleResolution": "node",
        "esModuleInterop": true,
        "types": [
            "node"
        ]
    }
}

script:
In order to compile and run dev server in watch mode.

npm install --save-dev tsc-watch

package.json
  "scripts": {
    "start": "tsc-watch --onSuccess \"node ./dist/index.js"
  },

Lets verify settings:

src/index.ts
 console.log('Hello GraphQL')
.....................................................................................

SDL implementation:

Steps:

1.Define schema
2.Write biz logic for schema - Resolver
3.Start Apollo Server

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `
 #Define api
 type Query{
   hello:String    
 } 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        hello() {
            return "Hello Graphql"
        }
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client code:
query HelloQuery {
  hello
}

Response:
{
  "data": {
    "hello": "Hello Graphql"
  }
}
.....................................................................................	
				Descriptions(docStrings)
.....................................................................................
Graphql schema definitions supports markdown enabled documentation strings called "descriptions"

This helps consumers of your graph discover fields and learn how to use them.

""Comments"" => single line comment
"""
 Multi line comment => Multi line
"""

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `
 #Define api
 type Query{
   """
    This is hello api which returns Hello Grapql Message
   """
   hello:String    
 } 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        hello() {
            return "Hello Graphql"
        }
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)
....................................................................................
			  Default Resolvers
....................................................................................

if you define query in the schema defintion, if you dont define resolver, the Apollo provides default Resolver which always returns null.

Eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `
 #Define api
 type Query{
   hello:String    
 } 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
       
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client Side:
query HelloQuery {
  hello
}

Response:
{
  "data": {
    "hello": null
  }
}
.....................................................................................
			  Multiple apis
....................................................................................

You can multiple apis in the schema 
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `
 #Define api
 type Query{
    add:Int
    multiply:Int
    div:Int
} 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        add() {
            return 10 + 10
        },
        multiply() {
            return 10 * 10
        },
        div() {
            return 10 / 2
        }

    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client Side:
query Add {
  add
}

query Multi {
  multiply
}

query Div {
  div
}

Response:
{
  "data": {
    "add": 20
  }
}
.....................................................................................
			 Object Types And Queries
.....................................................................................

Eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `

type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
}

type Query{
   user:User
} 

`
//Mock user data
const user = {
    id: 1,
    firstName: 'Subramanian',
    lastName: 'Murugan',
    age: 43,
    points: 1000,
    status: true
}

//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        user() {
            return user 
        }
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client Side:
query UserInfo {
  user {
    id
    firstName
    lastName    
    status
    points
  }
}
Response:

{
  "data": {
    "user": {
      "id": "1",
      "firstName": "Subramanian",
      "lastName": "Murugan",
      "status": true,
      "points": 1000
    }
  }
}
....................................................................................
				Collections
....................................................................................

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `

type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
}

type Query {
   users:[User]
} 

`
//Mock user data
const users = [{
    id: 1,
    firstName: 'Subramanian',
    lastName: 'Murugan',
    age: 43,
    points: 1000,
    status: true
},
{
    id: 2,
    firstName: 'Geetha',
    lastName: 'Subramanian',
    age: 40,
    points: 5000,
    status: true
},
{
    id: 3,
    firstName: 'Ram',
    lastName: 'M',
    age: 30,
    points: 5000,
    status: false
}

]

//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        users() {
            return users
        }
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client:
query UserInfo {
  users {
    id
    firstName
    lastName    
    status
    points
  }
}

Response:
{
  "data": {
    "users": [
      {
        "id": "1",
        "firstName": "Subramanian",
        "lastName": "Murugan",
        "status": true,
        "points": 1000
      },
      {
        "id": "2",
        "firstName": "Geetha",
        "lastName": "Subramanian",
        "status": true,
        "points": 5000
      },
      {
        "id": "3",
        "firstName": "Ram",
        "lastName": "M",
        "status": false,
        "points": 5000
      }
    ]
  }
}
...................................................................................
			 Null and Not Null
...................................................................................
How to handle null and not null?

Without Null: with data

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
}

type Query {
    user:User
}


`
const resolvers = {
    Query: {
        user() {
            return {
                id: 1,
                firstName: 'Subramanian',
                lastName: 'Murugan',
                age: 43,
                points: 100,
                status: false
            }
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Query:
query UserInfo {
  user {
    id
    firstName
  }
}

Response:
{
  "data": {
    "user": {
      "id": "1",
      "firstName": "Subramanian"
    }
  }
}
.................................................................................

With null:

const resolvers = {
    Query: {
        user() {
               return null;
        }
    },

}
Response:
{
  "data": {
    "user": null
  }
}
i dont want null, my api must always return data.

type Query {
    user:User!
}
Here "user" api must return data, if you return null 

Server will throw "Exception"

{
  "data": {},
  "errors": [
    {
      "message": "Cannot return null for non-nullable field Query.user.",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
      "path": [
        "user"
      ],
}
...................................................................................
				Fields not Null.

Fields not Null:

type User {
    id:ID!
    firstName:String!
    lastName:String!
    age:Int
    points:Float
    status:Boolean
}

const resolvers = {
    Query: {
        user() {
            return {
                firstName: 'Subramanian',
                lastName: 'Murugan',
                age: 43,
                points: 100,
                status: false
            }
        }
    },

}
Here "id" is missing, so the server will throw exception

{
  "data": {},
  "errors": [
    {
      "message": "Cannot return null for non-nullable field User.id.",
      "locations": [
        {
          "line": 3,
          "column": 5
        }
      ]
}
...................................................................................
			 Collections and null
....................................................................................

Syntax:
  products:[Product!]
  products:[Product]!
  products:[Product!]!


products:[Product!]:
...................
products:null -valid
products:[] - empty array -valid
products:[{id:1}] - arrays with data - valid
products:[null]

eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type User {
    id:ID!
    firstName:String!
    lastName:String!
    age:Int
    points:Float
    status:Boolean
}

type Query {
    users:[User!]
}


`
const resolvers = {
    Query: {
        users() {
            // return [{
            //     id:1,
            //     firstName: 'Subramanian',
            //     lastName: 'Murugan',
            //     age: 43,
            //     points: 100,
            //     status: false
            // }]
           // return null;
           return [null]
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Query:
query UserInfo {
  users {
    id
    firstName
    lastName
    status
    points
  }
}

Response:

  "data": {
    "users": null
  },
  "errors": [
    {
      "message": "Cannot return null for non-nullable field Query.users.",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ]
}
.....................................................................................

products:[String]!

Empty Array:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type Query {
    skills:[String]!
}
`
const resolvers = {
    Query: {
        skills() {
            return []
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client Side:
query Skills {
  skills
}

Response:
{
  "data": {
    "skills": []
  }
}

With data:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type Query {
    skills:[String]!
}
`
const resolvers = {
    Query: {
        skills() {
            
            return ['Graphql']
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client Side:
query Skills {
  skills
}

Response:
{
  "data": {
    "skills": [
      "Graphql"
    ]
  }
}

With Null
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type Query {
    skills:[String]!
}
`
const resolvers = {
    Query: {
        skills() {
               return null 
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client Side:
query Skills {
  skills
}


Response:
{
  "data": {},
  "errors": [
    {
      "message": "Cannot return null for non-nullable field Query.skills.",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
      "path": [
        "skills"
      ],
}


Inside Null: vaild
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type Query {
    skills:[String]!
}
`
const resolvers = {
    Query: {
        skills() {
               return [null]
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client Side:
query Skills {
  skills
}

Response:
{
  "data": {
    "skills": [
      null
    ]
  }
}
.....................................................................................

skills:[String!]!

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type Query {
    skills:[String!]!
}
`
const resolvers = {
    Query: {
        skills() {
              //return [null]
              //return null
              return []
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client side:

query Skills {
  skills
}

Response:
{
  "data": {},
  "errors": [
    {
      "message": "Cannot return null for non-nullable field Query.skills.",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
      "path": [
        "skills"
      ],
}
.....................................................................................
			Handling Args and Parameters
.....................................................................................

Handling args and parameters inside resolver.

Resolver functions takes four positional optional args.

resolverfun(parent,args,contextValue,info){

}

"args" variable is going to hold parameters passed by clients.
args value is going to be literal object

How many parameters you can pass, all parameters are stored inside single literal object.

Eg:
Simple Arg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type Query {
   hello(name:String):String
}
`
const resolvers = {
    Query: {
        hello(parent, args, ctx, info) {
            return `Hello ${args.name}`;
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client Side:
query HelloQueryParameter($name: String) {
  hello(name: $name)
}

Variables:
{
  "name": "Ram"
}
Response:
{
  "data": {
    "hello": "Hello Ram"
  }
}
...................................................................................
			 Not Null with args and return type
..................................................................................

Eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `
 
type Query {
   hello(name:String!):String!
}
`
const resolvers = {
    Query: {
        hello(parent, args, ctx, info) {
            return `Hello ${args.name}`;
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Clientside:
query HelloQueryParameter($name: String!) {
  hello(name: $name)
}

Variable:
{
  "name": null
}
You will get Exception.

{
  "data": {},
  "errors": [
    {
      "message": "Variable \"$name\" of non-null type \"String!\" must not be null.",
      "location"
}
....................................................................................
			How to handle complex args
..................................................................................

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `

type User {
    id:ID!
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
}

type Query {
   users:[User!]!
   user(id:ID!):User
}
`
const users = [{
    id: 1,
    firstName: 'Subramanian',
    lastName: 'Murugan',
    age: 43,
    points: 1000,
    status: true
},
{
    id: 2,
    firstName: 'Geetha',
    lastName: 'Subramanian',
    age: 40,
    points: 5000,
    status: true
},
{
    id: 3,
    firstName: 'Ram',
    lastName: 'M',
    age: 30,
    points: 5000,
    status: false
}

]



const resolvers = {
    Query: {
        users() {
            return users;
        },
        user(_, args) {
            return users.find(user => {
                //+ operator is used to convert string to number
                return user.id === +args.id
            })
        }
    },
}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client side:
query UsersById($userId: ID!) {
  user(id: $userId) {
    id
    firstName
    lastName
    age
    status
    points
  }
}

Variables:
{
  
  "userId": 1
}
Response:
{
  "data": {
    "user": {
      "id": "1",
      "firstName": "Subramanian",
      "lastName": "Murugan",
      "age": 43,
      "status": true,
      "points": 1000
    }
  }
}
.....................................................................................
			  Input type
....................................................................................

user(id:ID!,status:Boolean,age:Int):User

 Here we need to pass three fields 

Instead we can simlify the fields:

input UserInput {
    id:ID!
    status:Boolean
    age:Int
}

type Query {
   users:[User!]!
   #user(id:ID!,status:Boolean,age:Int):User
   user(userInput:UserInput!):User
}


eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `

type User {
    id:ID!
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
}

input UserInput {
    id:ID!
    status:Boolean
    age:Int
}

type Query {
   users:[User!]!
   #user(id:ID!,status:Boolean,age:Int):User
   user(userInput:UserInput!):User
}
`
const users = [{
    id: 1,
    firstName: 'Subramanian',
    lastName: 'Murugan',
    age: 43,
    points: 1000,
    status: true
},
{
    id: 2,
    firstName: 'Geetha',
    lastName: 'Subramanian',
    age: 40,
    points: 5000,
    status: true
},
{
    id: 3,
    firstName: 'Ram',
    lastName: 'M',
    age: 30,
    points: 5000,
    status: false
}

]



const resolvers = {
    Query: {
        users() {
            return users;
        },
        user(_, args) {
            console.log(args)
            return users.find(user => {
                //+ operator is used to convert string to number
                return user.id === +args.userInput.id
            })
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


query UsersById($userId: ID!, $status: Boolean = true, $age: Int = 18) {
  user(id: $userId, status: $status, age: $age) {
    id
    firstName
    lastName
    age
    status
    points
  }
}

Response:
{
  "data": {
    "user": {
      "id": "1",
      "firstName": "Subramanian",
      "lastName": "Murugan",
      "age": 43,
      "status": true,
      "points": 1000
    }
  }
}

What if there is more no of fields to need to be passed as arg.

Thats where input type is coming into picture.
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const typeDefs = `

type User {
    id:ID!
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
}

input UserInput {
    id:ID!
    status:Boolean
    age:Int
}

type Query {
   users:[User!]!
   #user(id:ID!,status:Boolean,age:Int):User
   user(userInput:UserInput!):User
}
`
const users = [{
    id: 1,
    firstName: 'Subramanian',
    lastName: 'Murugan',
    age: 43,
    points: 1000,
    status: true
},
{
    id: 2,
    firstName: 'Geetha',
    lastName: 'Subramanian',
    age: 40,
    points: 5000,
    status: true
},
{
    id: 3,
    firstName: 'Ram',
    lastName: 'M',
    age: 30,
    points: 5000,
    status: false
}

]



const resolvers = {
    Query: {
        users() {
            return users;
        },
        user(_, args) {
            console.log(args)
            return users.find(user => {
                //+ operator is used to convert string to number
                return user.id === +args.userInput.id
            })
        }
    },

}
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client side:

query UsersById($userInput: UserInput!) {
  user(userInput: $userInput) {
    id
    firstName
    lastName
    age
    status
    points
  }
}
Variables:

{
  
  "userInput": {
     "id": 1,
     "age":34,
     "status":true

  }
Response:
{
  "data": {
    "user": {
      "id": "1",
      "firstName": "Subramanian",
      "lastName": "Murugan",
      "age": 43,
      "status": true,
      "points": 1000
    }
  }
}
Console output:
{ userInput: { id: '1', status: true, age: 34 } }



.....................................................................................
			      Nested Fields
.....................................................................................

We can return nested  fields in two ways

1.As part of the object
2.Two different Objects and stiching together.


1.As part of the object
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `

type Address {
    city:String
}

type User {
    id:ID!
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
    address:Address
}

 #Define api
 type Query{
    user:User
 } 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        user() {
            return {
                id: 1,
                firstName: 'Subramanian',
                lastName: 'Murugan',
                status: true,
                age: 43,
                points: 120.7,
                //nested field
                address: {
                    city: 'Coimbatore'
                }

            }
        }
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client side:
query User {
  user {
    id
    firstName
    lastName
    status
    points
    age
    address {
      city
    }
  }
}

Response:
{
  "data": {
    "user": {
      "id": "1",
      "firstName": "Subramanian",
      "lastName": "Murugan",
      "status": true,
      "points": 120.7,
      "age": 43,
      "address": {
        "city": "Coimbatore"
      }
    }
  }
}
.....................................................................................
			Nested Fields From Different Objects
			    Resolver Chains
...................................................................................
Resolver chains means coimbining results of one resolver with in nested Resolvers


import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//Mock data
const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'

},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'

},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}]

const ADDRESS = [{
    city: 'CBE',
    state: 'TN',
    id: 1 //link field
},
{
    city: 'CHN',
    state: 'TN',
    id: 2 //link field
},
{
    city: 'BNG',
    state: 'KA',
    id: 3 //link field
}
]


//1.Define Schema 
const typeDefs = `

type Address {
    city:String
    state:String    
}

type User {
    id:ID!
    name:String
    email:String
    address:Address
}

 #Define api
 type Query{
    users:[User!]!
 } 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
         users(){
            return USERS
         }
    },
    
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client Side:
query USERS {
  users {
    id
    name
    email
    address {
      city
      state
    }
  }
}

Response:
{
  "data": {
    "users": [
      {
        "id": "1",
        "name": "A",
        "email": "a@gmail.com",
        "address": null
      },
      {
        "id": "2",
        "name": "B",
        "email": "b@gmail.com",
        "address": null
      },
      {
        "id": "3",
        "name": "C",
        "email": "c@gmail.com",
        "address": null
      }
    ]
  }
}

Here address is null because, the address data is not linked.
In the above mock, address and users are separate data structure. Now we need to coimbine them via resolvers.
   =>Resolver Chain
            Coimbining dependant data which are coming from different datasource.


import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//Mock data
const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'

},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'

},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}]

const ADDRESS = [{
    city: 'CBE',
    state: 'TN',
    id: 1 //link field
},
{
    city: 'CHN',
    state: 'TN',
    id: 2 //link field
},
{
    city: 'BNG',
    state: 'KA',
    id: 3 //link field
}
]


//1.Define Schema 
const typeDefs = `

type Address {
    city:String
    state:String    
}

type User {
    id:ID!
    name:String
    email:String
    address:Address # in Resolver chain address becomes api
}

 #Define api
 type Query{
    users:[User!]!
 } 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        users(parent, args, ctx, info) {
            return USERS
        }
    },
    //Resolver Chain
    User: {
        address(parent, args, ctx, info) {
            console.log('Address Parent =>', parent)
            return ADDRESS.find(address => {
                //address.id === user.id
                return address.id === parent.id
            })
        }
    }


}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client Side:

query USERS {
  users {
    id
    name
    email
    address {
      city
      state
    }
  }
}

Response:
{
  "data": {
    "users": [
      {
        "id": "1",
        "name": "A",
        "email": "a@gmail.com",
        "address": {
          "city": "CBE",
          "state": "TN"
        }
      },
      {
        "id": "2",
        "name": "B",
        "email": "b@gmail.com",
        "address": {
          "city": "CHN",
          "state": "TN"
        }
      },
      {
        "id": "3",
        "name": "C",
        "email": "c@gmail.com",
        "address": {
          "city": "BNG",
          "state": "KA"
        }
      }
    ]
  }
}
.....................................................................................
			 Complex use Case:

There are libraries which are located across city.
There are books which belongs certain libraries , i want to know which book blongs which lib.

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//libraries

const libraries = [
    {
        branch: 'TownHall'
    },
    {
        branch: 'RiverSide'
    }
]
const BOOKS = [{
    title: 'Graphql In Action',
    author: 'Subramanian',
    branch: 'TownHall'
},
{
    title: 'Apollo Server',
    author: 'John',
    branch: 'RiverSide'
}
,{
    title: 'Moon Landing Mission',
    author: 'Ram',
    branch: 'RiverSide'
}

]



//1.Define Schema 
const typeDefs = `

#A library has a branch and book
type Library{
   branch:String! # link field
   books:[Book!]
}
type Book{
  title:String
  author:Author! # api for Book  
}
type Author{
  name:String!   
}

 #Define api
 type Query{
   libraries:[Library]
 } 

`
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        libraries() {
            return libraries;
        }
    },
    //Resolver Chain
    Library: {
        books(parent) {
            return BOOKS.filter(book => {
                return book.branch === parent.branch
            })
        }
    },
    Book: {
        author(parent) {
            //Author is Object so we need to return object
            return {
                name: parent.author
            }
        }
    }


}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client Side:
query GetLib {
  libraries {
    branch
    books {
      title
      author {
        name
      }
    }
  }
}

Response:
{
  "data": {
    "libraries": [
      {
        "branch": "TownHall",
        "books": [
          {
            "title": "Graphql In Action",
            "author": {
              "name": "Subramanian"
            }
          }
        ]
      },
      {
        "branch": "RiverSide",
        "books": [
          {
            "title": "Apollo Server",
            "author": {
              "name": "John"
            }
          },
          {
            "title": "Moon Landing Mission",
            "author": {
              "name": "Ram"
            }
          }
        ]
      }
    ]
  }
}
.....................................................................................
			   Union Types
....................................................................................

Unions are abstract graphql types that enables a schema field to return one of multiple object types,

How to define Union Type?

 union Media = Book | Movie

type Query{
 allMedia:Media
}

union searchResult =  Book | Author

type Book{
  title:String!
}
type Author {
  name:String!
}
type Query{
  search(contains:String):[SearchResult!]
}

Query:
 query {
   ...on Book{}
   ...on Movie{}
 }

How Apollo Server returns data based on "Union" Type?

 __resolveType function

  Media: {
     __resolveType(obj,ctx,info){
	  if(obj.movie){
		return 'Movie' // Type Must be String
	  }
          if(obj.author){
		return 'Book'
	  }
          return null
      }
  }

EG:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'



//1.Define Schema 
const typeDefs = `

union CandyResult = Candy | OutOfStock | RegionUnAvilability

type Candy{
   id:String!
   name:String!    
   price:Float
}

type OutOfStock{
    name:String
    id:String
    restockDate:String
}

type RegionUnAvilability{
    id:String
    name:String
    availableRegions:[String!]
}

type Query{
    candy(id:String!):CandyResult    
}

`
const data = [
    {
        "id": "gummy-bears",
        "name": "Gummy Bears",
        "price": 1000
    },
    {
        "id": "sour-patch",
        "name": "Sour Patch Kids",
        "price": 1000
    },
    {
        "id": "Wonka-nerds",
        "name": "Wonka-nerds",
        "restockDate": "2023-09-06"
    },
    {
        "id": "Wonka-nerds",
        "name": "Wonka-nerds",
        "availableRegions": ["Coimbatore", "Chennai", "Banaglore"]
    }
]

//2.Biz logic for hello Query : Resolvers
const resolvers = {
    //Union Type Resolution Code
    CandyResult: {
        __resolveType(obj, ctx, info) {
            //we need to pass unique field to resolve
            if (obj.restockDate) {
                return 'OutOfStock'
            }
            if (obj.availableRegions) {
                return 'RegionUnAvilability'
            }
            if (obj.price) {
                return 'Candy'
            }
            return null
        }
    },
    Query: {
        candy(_, args) {
            return data.find(item => {
                return item.id === args.id
            })
        }
    }
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Query:
query Candy($candyId: String!) {
  candy(id: $candyId) {
    ... on Candy {
      price
      candyName:name
      candyID:id
    }
    ... on OutOfStock {
      mystock:id
      stock:name
      restockDate
    }
    ... on RegionUnAvilability {
      id 
      name
      availableRegions
    }
  }
}

variables:
{
  "candyId": "Wonka-nerds"
}

Response:
{
  "data": {
    "candy": {
      "mystock": "Wonka-nerds",
      "stock": "Wonka-nerds",
      "restockDate": "2023-09-06"
    }
  }
}
....................................................................................
			 Interface Type
....................................................................................

An interface specifies a set of "fields" that mutiple object types can include.

interface Book{
  title:String!
  author:Author!
}

type TextBook implements Book{
  title:String!
  author:Author!
  courses:[Course!]!
}
type ColoringBook implements Book{
  title:String!
  author:Author!
  colors:[String!]!
}

type Query {
  books:[Book!]! #Can Include TextBook or any Book Objects
}

Resolvers:
const resolvers = {
  Book: {
    __resolveType(book,ctx,info){
	if(book.courses){
	    return 'TextBook'
        }
	if(book.courses){
	    return 'ColoringBook'
        }	 
	return null
     }
  }

}

Final Code:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//1.Define Schema 
const typeDefs = `
interface Book {
    title:String!
    author:Author!
}
type Author{
   name:String
}
type Course {
   name:String    
}
type Textbook implements Book {
    title:String!
    author:Author!
    courses:Course
}
type ColoringBook implements Book {
    title:String!
    author:Author!
    colors:[String!]!
}
 
type Query {
    books:[Book!]!
}
`
//Mock data f
const BOOKS = [{
    title: 'Apollo Graphql in Action',
    author: {
        name: 'Subramanian'
    },
    courses: {
        name: 'IT'
    }
},
{
    title: 'Birds Drawing for Kids',
    author: {
        name: 'John'
    },
    colors: ['Green', 'Yellow']
}
]


//2.Biz logic for hello Query : Resolvers
const resolvers = {

    Query: {
        books() {
            return BOOKS;
        }
    },
    Book: {
        __resolveType(book, ctx, info) {
            if(book.courses){
                return 'Textbook' //Type must be String
            }
            if(book.colors){
                return 'ColoringBook'
            }
            return null
        }
    }

}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client Side:
query Books {
  books {
    __typename
    title
    author {
      name
    }
    ... on Textbook {
      courses {
        name
      }
    }
    ... on ColoringBook {
      colors
    }
  }
}

Response:
{
  "data": {
    "books": [
      {
        "__typename": "Textbook",
        "title": "Apollo Graphql in Action",
        "author": {
          "name": "Subramanian"
        },
        "courses": {
          "name": "IT"
        }
      },
      {
        "__typename": "ColoringBook",
        "title": "Birds Drawing for Kids",
        "author": {
          "name": "John"
        },
        "colors": [
          "Green",
          "Yellow"
        ]
      }
    ]
  }
}
.....................................................................................
			  Context and Context Values
.....................................................................................

What is Context?

Context is object is used to share "Information and Request Details" throughout application.

During a Graphql Operation, you can share data throught your server's resolvers and plugins by creating an object named called contextValue.

We can pass some usefull information via context like authentication tokens, datasources,global api keys.


The context function:
 The context is a function which is part of startStandaloneServer.
 This function must return async value /Object Via "Promise".

The object which we return from "context function "  can be access inside resolver.

eg:
  resolverFun(parent,args,contextValue,info){
	contextValue.somedata
  }

Simple Context :
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//Context Type:Type script syntax to have strong typing
interface MyContext {
    greet: String
}

//1.Define Schema 
const typeDefs = `
  type Query {
    hello:String
  }
`


//2.Biz logic for hello Query : Resolvers
const resolvers = {

    Query: {
        hello(parent, args, contextValue, info) {
            return `${contextValue.greet}`
        }
    }


}


//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer<MyContext>({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    },
    context: async (obj) => {
        return {
            greet: 'Welcome'    //return Promise.resolve({greet:'Welcome'})
        }
    }
})
console.log(`Apollo Server is Ready ${url}`)
.....................................................................................
			  Data Sources & Context
....................................................................................

DataSources:
 The place where data is stored.

Data sources
1.InMemory Datasource - Arrays
2.Databases 
3.Third Party apis
  -Rest api
  -Another graphql api
  -Grpc API

As of now we have written biz logic inside resolvers, which is not recommended, we have to write biz logic outside resolvers called "Services"/Datasources

1.InMemory Data Sources

Steps:
1.write service class
src/services/comments.service.ts
import { COMMENTS } from "../mock-data/comments.js";

//DataSource class//Service class 
export class CommentService {
    constructor() { }
    //all biz apis : CURD operations
    findAll() {
        return COMMENTS
    }
    findById(id: number) {
        return COMMENTS.find(comment => {
            console.log(comment.id , id)
            return comment.id === id
        })
    }
    //save
    save(comment) {
        //save logic
        return comment
    }
    //update

    //delete
}
2.Mock data preparation: Please refer code repo.

Note: YOu have to implement three logic : save,update,delete


3.Define schema,resolvers,context
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { CommentService } from "./services/Comments.service.js"
// import { COMMENTS } from "./mock-data/comments.js"

//Context Type:Type script syntax to have strong typing
interface MyContext {
    dataSources: {
        commentsAPI: CommentService
    }
}

//1.Define Schema 
const typeDefs = `

type Comment{ 
    postId:Int
    id:ID
    name:String
    email:String
    body:String
}

type Query {
    comments:[Comment]!
    comment(id:ID):Comment
}

`


//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        comments(parent, args, context, info) {
            //ACCESS data source /service object
            return context.dataSources.commentsAPI.findAll()
        },
        comment(parent, args, context, info) {
            return context.dataSources.commentsAPI.findById(+args.id);
        }
    }


}


//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer<MyContext>({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    },
    context: async (obj) => {
        return {
            dataSources: {
                commentsAPI: new CommentService()
            }
        }
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client side:

query COMMENTS {
  comments {
    postId
    name
    id
    email
    body
  }
}

Response:
{
  "data": {
    "comments": [
      {
        "postId": 1,
        "name": "id labore ex et quam laborum",
        "id": "1",
        "email": "Eliseo@gardner.biz",
        "body": "laudantium enim quasi est quidem magnam voluptate ipsam eos\ntempora quo necessitatibus\ndolor quam autem quasi\nreiciendis et nam sapiente accusantium"
      },
      {
        "postId": 1,
        "name": "quo vero reiciendis velit similique earum",
        "id": "2",
        "email": "Jayne_Kuhic@sydney.com",
        "body": "est natus enim nihil est dolore omnis voluptatem numquam\net omnis occaecati quod ullam at\nvoluptatem error expedita pariatur\nnihil sint nostrum voluptatem reiciendis et"
      },
]

query CommentsById($id:ID) {
  comment(id:$id) {
    postId
    name
    id
    email
    body
  }
}
Variables:
{
  "id":300
}
Response:
{
  "data": {
    "comment": {
      "postId": 60,
      "name": "in dolore iusto ex molestias vero",
      "id": "300",
      "email": "Letha@liliane.ca",
      "body": "dolorem fugit quidem animi quas quisquam reprehenderit\noccaecati et dolor laborum nemo sed quas unde deleniti\nfacere eligendi placeat aliquid aspernatur commodi sunt impedit\nneque corrupti alias molestiae magni tempora"
    }
  }
}

.....................................................................................
			  Mutation - CREATE,UPDATE,DELETE

Note: You have to implement biz logic for create,update,delete.


import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { CommentService } from "./services/Comments.service.js"
// import { COMMENTS } from "./mock-data/comments.js"

//Context Type:Type script syntax to have strong typing
interface MyContext {
    dataSources: {
        commentsAPI: CommentService
    }
}

//1.Define Schema 
const typeDefs = `

type Comment{ 
    postId:Int
    id:ID
    name:String
    email:String
    body:String
}

type Query {
    comments:[Comment]!
    comment(id:ID):Comment
}

input InputCommentCreate {
    postId:Int
    id:ID
    name:String
    email:String
    body:String
}
input InputCommentUpdate {
    postId:Int
    id:ID
    name:String
    email:String
    body:String
}
type Mutation {
    addComment(comment:InputCommentCreate):Comment
    updateComment(id:ID!,comment:InputCommentUpdate):Comment
    removeComment(id:ID!):Boolean
}

`


//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        comments(parent, args, context, info) {
            //ACCESS data source /service object
            return context.dataSources.commentsAPI.findAll()
        },
        comment(parent, args, context, info) {
            return context.dataSources.commentsAPI.findById(+args.id);
        }
    },
    Mutation: {
        addComment(parent, args, context, info) {
            return context.dataSources.commentsAPI.save(args.comment)
        },
        updateComment(parent, args, context, info) {
            return context.dataSources.commentsAPI.update(+args.id, args.comment)
        },
        removeComment(parent, args, context, info) {
            return context.dataSources.commentsAPI.remove(+args.id)
        }
    }


}


//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer<MyContext>({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    },
    context: async (obj) => {
        return {
            dataSources: {
                commentsAPI: new CommentService()
            }
        }
    }
})
console.log(`Apollo Server is Ready ${url}`)


ClientSide:
mutation CreateComment($comment: InputCommentCreate) {
  addComment(comment: $comment) {
    id
    postId
    name
    email
    body
  }
}

Variables:
{
  "comment": {
     "id":1000,
     "postId":100,
     "name":"Learn Graphql",
     "email":"test@gmail.com",
     "body":"aldfjaldkfjdsaflkjsa",     
  }
}
Response:
{
  "data": {
    "addComment": {
      "id": "1000",
      "postId": 100,
      "name": "Learn Graphql",
      "email": "test@gmail.com",
      "body": "aldfjaldkfjdsaflkjsa"
    }
  }
}
....................................................................................
			 REST API as Datasource
....................................................................................

In order to communitate REST End Points , we can use "RESTDataSource".

The RESTDataSource class simplifies fetching data from REST API and helps handle caching,request deduplication,and errors while resolving operations.

steps:
1.you need to install rest datasource
npm install @apollo/datasource-rest


Service:
import { RESTDataSource } from "@apollo/datasource-rest";

interface Post {
    userId: number
    id: number
    title: string
    body: string
}
export class PostService extends RESTDataSource {
    override baseURL = `https://jsonplaceholder.typicode.com`
    //api
    public async getPosts(): Promise<Post[]> {
        return this.get<Post[]>(`posts`)
    }
    public async getPostById(id: number): Promise<Post> {
        return this.get<Post>(`posts/${id}`)
    }
    //save
    public async createPost(post: Post): Promise<Post> {
        return await this.post<Post>(`posts`, { body: post })
    }
    //update
    public async updatePost(id: number, post: Post): Promise<Post> {
        return await this.put<Post>(`posts/${id}`, { body: post })
    }
    //DELETE 
    public async removePost(id: number) {
        console.log(id)
        return await this.delete(`posts/${id}`) 
    }
}
..
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { PostService } from "./services/Post.service.js"


//Context Type:Type script syntax to have strong typing
interface MyContext {
    dataSources: {
        postAPI: PostService
    }
}

//1.Define Schema 
const typeDefs = `

type Post{
    userId:Int!
    id:ID!
    title:String
    body:String
}

type Query{
    posts:[Post!]!
    post(id:ID!):Post!
}
input PostCreateInput {
    userId:Int!
    title:String
    body:String
}
input PostUpdateInput {
    title:String
    body:String
}

type PostResponse{
    userId:Int
    id:ID
    title:String
    body:String
}

type Mutation {
    createPost(post:PostCreateInput):Post
    updatePost(id:ID!,post:PostUpdateInput):Post
    removePost(id:ID!):PostResponse
}

`


//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        async posts(parent, args, ctx, info) {
            return ctx.dataSources.postAPI.getPosts()
        },
        async post(parent, args, ctx, info) {
            return ctx.dataSources.postAPI.getPostById(+args.id)
        }
    },
    Mutation: {
        async createPost(parent, args, ctx, info) {
            return ctx.dataSources.postAPI.createPost(args.post)
        },
        async updatePost(parent, args, ctx, info) {
            return ctx.dataSources.postAPI.updatePost(+args.id, args.post)
        },
        async removePost(parent, args, ctx, info) {
            return ctx.dataSources.postAPI.removePost(+args.id)
        }
    }


}


//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer<MyContext>({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    },
    context: async (obj) => {
        return {
            dataSources: {
                postAPI: new PostService()
            }
        }
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client side:
Query:
query Posts {
  posts {
    userId
    id
    title
    body
  }
}

query PostsByid($postId: ID!) {
  post(id: $postId) {
    userId
    id
    title
    body
  }
}

Mutation:
mutation CREATEPOST($post: PostCreateInput) {
  createPost(post: $post) {
    id
    userId
    title
    body
  }
}
Variables:
{
  "post":{
    "userId": 1,
    "title":"learn apollo",
    "body" :"Apollo Graphql"    
  }
}

Update:
mutation UPDATEPOST($updatePostId: ID!, $post: PostUpdateInput){
   updatePost(id: $updatePostId,post: $post) {
     id
     title
     body
   }
}


Remove:
mutation REMOVEPOST($removePostId: ID!){
  removePost(id: $removePostId) {
    title
    body
  }
}
{
  "updatePostId": 1,
  "post": {
    "title":"TEST",
    "body": "HOW ARE YOU"
  }
}
Variables
{
  "removePostId": 3
}
.....................................................................................	
			   Database Interaction
.....................................................................................

ORM Frameworks:

Java Developers use "Hibernate" ORM framework

What about ORM framework for node.js developers?

1.Prisma
2.Sequelize
3.TypeOrm
4.Knex
etc...

Prisma:
  Prisma is more declarative ORM framework for node.js and typescript based apps.
  Prisma can talk to sql databases and also no sql databases like mongodb.

Prisma tools set:
1.Prisma client   
   Auto generated and type safe query build for node and typescript.

2.Prisma migrate
    Migration system for Prisma

3.Prisma Studio 
   GUI tool to view and edit in your database.

How does prisma work?

Prisma schema :
  Every app uses a tool from prisma toolki starts with Prisma schema file.

Prisma Schema defins the "application models" in an intuitive data modeling language.
It also contains the connection to a database and defines a generator.


datasources db {
  provider = "mysql"
  url = env("DATABASE_URL")
}
generator client {
  provider ="prisma-client"
}

//model configuration

model Post {
 id Int @id @default(autoincrement())
 title String
}
.....................................................................................
Prisma Setup:
............

1.You need to select what database you are going to connect.
  Postgresql,MySql,Mariadb,Oracle,DB2,Mongo db etc.....

2.I am going to use "in Memory database" - You dont need to install any database.
  but this is not for production.
   "sqlite" - Most popular inMemory database..
 

Steps:

install prisma dependency:

npm install prisma 

npx prisma init --datasource-provider sqlite

✔ Your Prisma schema was created at prisma/schema.prisma
  You can now open it in your favorite editor.

Next steps:
1. Set the DATABASE_URL in the .env file to point to your existing database. If your database has no tables yet, read https://pris.ly/d/getting-started
2. Run prisma db pull to turn your database schema into a Prisma schema.
3. Run prisma generate to generate the Prisma Client. You can then start querying your database.

More information in our documentation:
https://pris.ly/d/getting-started


2.Declare Model
 Model represents database table.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}
//Model declaration
model User{
  id Int @id @default(autoincrement())
  name String?
  email String @unique
  createdAt DateTime @default(now())
}

3.Database Migration
  Convert this schema into tables and connecting database...


npx prisma migrate dev
Environment variables loaded from .env
Prisma schema loaded from prisma\schema.prisma
Datasource "db": SQLite database "dev.db" at "file:./dev.db"

SQLite database dev.db created at file:./dev.db

√ Enter a name for the new migration: ...
Applying migration `20230911131001_`

The following migration(s) have been created and applied from new schema changes:

migrations/
  └─ 20230911131001_/
    └─ migration.sql

Your database is now in sync with your schema.

Running generate... (Use --skip-generate to skip the generators)

added 2 packages, and audited 161 packages in 5s

9 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

✔ Generated Prisma Client (v5.2.0) to .\node_modules\@prisma\client in 83ms

migration.sql
-- CreateTable
CREATE TABLE "User" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "name" TEXT,
    "email" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
.....................................................................................

4.Setup Prisma Client lib:

npm i @prisma/client

src/database.ts
import { PrismaClient } from "@prisma/client";
export const prisma =  new PrismaClient();


CURD Operations:
................
prisma.modelName.api

eg:
prisma.user.findMany({}) - Read All
prisma.user.findUnique({
 where: {
   email:'test@gmail.com'
 }
}) - find By 

prisma.user.create({
  data: {
    email:'test@gmail.com'
    name:'test'
  }
}) - create method

prisma.user.update({
 where: {
   id:1
 },
 data: {
   email:''
 }
})

prisma.user.delete({
  where: {
    id:1
  }
})
.....................................................................................


CURD Operations: Read and Save

src/services/User.service.ts

import { prisma } from "../database.js"

export class User {
    id: number
    name: string
    email: string
    createdAt: string
}

export class UserService {

    public findAll() {
        return prisma.user.findMany({})
    }
    public save(user: User) {
        return prisma.user.create({
            data: {
                email: user.email,
                name: user.name,
                createdAt: new Date()
            }
        })
    }
}

src/index.ts
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { UserService } from "./services/User.service.js"


//Context Type:Type script syntax to have strong typing
interface MyContext {
    dataSources: {
        userAPI: UserService
    }
}

//1.Define Schema 
const typeDefs = `
type User {
    id:Int
    name:String
    email:String
    createdAt:String
}
type Query {
    users:[User]
}
input UserCreateInput {
    name:String
    email:String
}

type Mutation {
    createUser(user:UserCreateInput):User
}

`

//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        users(parent, args, context, info) {
            return context.dataSources.userAPI.findAll()
        }
    },
    Mutation: {

        async createUser(parent, args, context, info) {
            return context.dataSources.userAPI.save(args.user)
        }

    }


}


//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer<MyContext>({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    },
    context: async (obj) => {
        return {
            dataSources: {
                userAPI: new UserService()
            }
        }
    }
})
console.log(`Apollo Server is Ready ${url}`)

..................................................................................

FindBy id,update,delete:
........................

src/services/User.service.ts


import { prisma } from "../database.js"

export class User {
    id: number
    name: string
    email: string
    createdAt: string
}

export class UserService {

    public findAll() {
        return prisma.user.findMany({})
    }

    public findById(id: number) {
        return prisma.user.findUnique({
            where: {
                id: id
            }
        })
    }
    public save(user: User) {
        return prisma.user.create({
            data: {
                email: user.email,
                name: user.name,
                createdAt: new Date()
            }
        })
    }
    public update(id: number, user: User) {
        return prisma.user.update({
            where: {
                id: id
            },
            data: {
                email: user.email
            }
        })
    }
    public remove(id: number) {
        return prisma.user.delete({
            where: {
                id: id
            }
        })
    }

}


src/index.ts

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { UserService } from "./services/User.service.js"


//Context Type:Type script syntax to have strong typing
interface MyContext {
    dataSources: {
        userAPI: UserService
    }
}

//1.Define Schema 
const typeDefs = `
type User {
    id:Int
    name:String
    email:String
    createdAt:String
}
type Query {
    users:[User]
    user(id:ID):User
}
input UserCreateInput {
    name:String
    email:String
}
input UserUpdateInput {
    name:String
    email:String
}
type Mutation {
    createUser(user:UserCreateInput):User
    updateUser(id:ID,user:UserUpdateInput):User
    removeUser(id:ID):User
    
}

`

//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        users(parent, args, context, info) {
            return context.dataSources.userAPI.findAll()
        },
        user(parent, args, context, info) {
            return context.dataSources.userAPI.findById(+args.id)
        }

    },
    Mutation: {
        async createUser(parent, args, context, info) {
            return context.dataSources.userAPI.save(args.user)
        },
        async updateUser(parent, args, context, info) {
            return context.dataSources.userAPI.update(+args.id, args.user)
        },
        async removeUser(parent, args, context, info) {
            return context.dataSources.userAPI.remove(+args.id)
        }
    }


}


//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer<MyContext>({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    },
    context: async (obj) => {
        return {
            dataSources: {
                userAPI: new UserService()
            }
        }
    }
})
console.log(`Apollo Server is Ready ${url}`)


Testing : Client 

CREATE:
mutation AddUSER($user: UserCreateInput) {
  createUser(user: $user) {
    id
    name
    email
    createdAt
  }
}

Variable:
{
  "user": {
    "name":"Murugan",
    "email":"murugan@gmail.com"
  }
}
Response:
{
  "data": {
    "createUser": {
      "id": 4,
      "name": "Murugan",
      "email": "murugan@gmail.com",
      "createdAt": "1694440575052"
    }
  }
}

Get All
query Users {
  users {
    id
    name
    email
    createdAt
  }
}

Response:
{
  "data": {
    "users": [
      {
        "id": 1,
        "name": "Subramnaian",
        "email": "sasubramaian_md@hotmail.com",
        "createdAt": "1694439551274"
      },
      {
        "id": 2,
        "name": "Geetha",
        "email": "subugee@gmail.com",
        "createdAt": "1694439879402"
      }
    ]
  }
}

User byId:
query UserById($userId: ID) {
  user(id: $userId) {
    id
    email
    name
    createdAt
  }
}
Variables:
{
  "userId": 3
}
Response:
{
  "data": {
    "user": {
      "id": 3,
      "email": "murugan@gmail.com",
      "name": "Murugan",
      "createdAt": "1694439903269"
    }
  }
}

UPDATE:
mutation UPDATUSER($id: ID, $user: UserUpdateInput) {
  updateUser(id: $id, user: $user) {
    id
    name
    email
    createdAt
  }
}
Variables:
{
  "id":3,
  "user": {
     "email": "murugan222@hotmail.com"
  }
}
Response:
{
  "data": {
    "updateUser": {
      "id": 3,
      "name": "Murugan",
      "email": "murugan222@hotmail.com",
      "createdAt": "1694439903269"
    }
  }
}

Remove:
mutation RemoveUser($removeUserId: ID) {
  removeUser(id: $removeUserId) {
    id
  }
}
Variables:
{
  "removeUserId": 4
}
Response:
{
  "data": {
    "removeUser": {
      "id": 4
    }
  }
}
.....................................................................................
			  Custom Scalar
.....................................................................................

The Graphql specification includes many built in scalars such ID,String,Boolean,Float,Int.

Apart from you can create your own custom types as well.

Inside Schema:
..............

scalar TypeName
scalar Date

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//1.Define Schema 
const typeDefs = `

#Custom data type
scalar Date

type User {
    id:ID!
    name:String
    email:String
    date:Date
}
type Query {
    users:[User]
}

`
const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com',
    date: new Date()
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com',
    date: new Date()
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com',
    date: new Date()
},

]
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        users(parent, args, ctx, info) {
            return USERS
        }
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

How to resolve/give meaning to the data type?

Steps:
1.Call GraphQLScalarType constructor function which returns object

const dateScalar = new GraphQLScalarType({
    name: 'Date',
    description: 'Date Date Type'
})


2.We need to attach in the resolver's configuration.

const resolvers = {
    Date:dateScalar,
    Query: {
        users(parent, args, ctx, info) {
            return USERS
        }
    },
 }

3. Add Methods into GraphQLScalarType

serialize:
   A function which converts the custom scalar type to value that can be seralized as a response by the graphql Server

parseValue:
  A function that convert the value received as a variable in the graphql query to the custom scalar type.

parseLiteral:
  A function that converts a literal received in the Graphql Query to the custom Scalar type.

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { GraphQLScalarType, Kind } from "graphql"

const dateScalar = new GraphQLScalarType({
    name: 'Date',
    description: 'Date  Type',
    serialize(value: Date) {
        //Logic to treate that data type
        console.log('seralize',value)
        return value.getTime()
    },
    parseValue(value: Date) {
        console.log('parseValue',value)
        //convert incoming integer to Date
        return new Date(value)
    },
    parseLiteral(ast) {
        console.log('parseLiteral',ast)

        if (ast.kind == Kind.INT) {
            return new Date(parseInt(ast.value, 10))
        }
        return null
    }

})


//1.Define Schema 
const typeDefs = `

#Custom data type
scalar Date

type User {
    id:ID!
    name:String
    email:String
    date:Date
}
type Query {
    users:[User]
}

`
const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com',
    date: new Date()
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com',
    date: new Date()
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com',
    date: new Date()
},

]
//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Date: dateScalar,
    Query: {
        users(parent, args, ctx, info) {
            return USERS
        }
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)
.....................................................................................
		 Custom Scalar for Restricting integers to Odd values
.....................................................................................
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { GraphQLError, GraphQLScalarType, Kind } from "graphql"

function oddValue(value:number ){
    if (typeof value === 'number' && Number.isInteger(value) && value % 2 !== 0) {
        return value
    }
    throw new GraphQLError('Provided Integer is not ODD integer', {
        extensions: { code: 'BAD_USER_INPUT' }
    })
}
const oddScalar = new GraphQLScalarType({
    name: 'Odd',
    description: 'Odd Custom data Type',
    parseValue(value: number) {
        if (typeof value === 'number' && Number.isInteger(value) && value % 2 !== 0) {
            return value
        }
        throw new GraphQLError('Provided Integer is not ODD integer', {
            extensions: { code: 'BAD_USER_INPUT' }
        })
    },
    serialize(value: number) {
        if (typeof value === 'number' && Number.isInteger(value) && value % 2 !== 0) {
            return value
        }
        throw new GraphQLError('Provided Integer is not ODD integer', {
            extensions: { code: 'BAD_USER_INPUT' }
        })
    },
    parseLiteral(ast){
        if(ast.kind === Kind.INT){
            return oddValue(parseInt(ast.value,10))
        }
        throw new GraphQLError('Provided Integer is not ODD integer', {
            extensions: { code: 'BAD_USER_INPUT' }
        })
    }

})


//1.Define Schema 
const typeDefs = `
 scalar Odd

 type Query {
    getOdd(odd:Odd!):Odd!
 }

`

//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Odd: oddScalar,
    Query: {
        getOdd(parent,args,ctx,info){
            return args.odd
        }
    },
    //Mutation
    //Subscription
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)

Client side:
query Query($odd: Odd!) {
  getOdd(odd: $odd)
}
Variables:

{
  "odd": 6
}

Response:
{
  "data": {},
  "errors": [
    {
      "message": "Variable \"$odd\" got invalid value 6; Provided Integer is not ODD integer",
      "locations": [
        {
          "line": 1,
          "column": 13
        }
      ],
      "extensions": {
        "code": "BAD_USER_INPUT"
}

Variables:
{
  "odd": 3
}
response:
{
  "data": {
    "getOdd": 3
  }
}
...................................................................................
			 Third party Custom Scalar types:
...................................................................................

There is one popular custom Apollographql custom scalar is "graphql-type-json"
....................................................................................
			Custom Direcitves
....................................................................................

What is Directive?
  Directive is a code or logic to be injected into the schema.
  A Directive decorates part of a Graphql Schema or Operations with additional configuration which is similar to "Annotations" in java.

Directive Syntax:

type MyType{
  field:String @directive(params:paramValue)
}

Graphql offers lot of built in directives, apart from even we can build our own directives as well- Custom Directives.

How to create Custom Directives?

  Apollo Server does not provide direct implementation.
  Apollo Server does not provide built in support for custom directives that transform schema.

@graphql/tools package offers features to create and integrate custom directives.

Apollo 4 offers graphql tools basic features as part of core lib, if you need custom directive features that tool must be installed.

npm install @graphql-tools/schema @graphql-tools/utils

Use Case:
 Field Upper Case Directive, if there is string fields , i want to show as upper cases

Directive Syntax:

directive @NameofTheDirective on FIELD_DEFINITION
eg:
directive @uppercase on FIELD_DEFINITION

Usage:
type User {
 name:String @uppercase
}
type Query { 
  hello:String @uppercase
}


code:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { mapSchema, MapperKind, getDirective } from '@graphql-tools/utils'
import { makeExecutableSchema } from '@graphql-tools/schema'
import { defaultFieldResolver } from 'graphql'

//1.Define Schema 
const typeDefs = `

type User {
    id:ID!
    name:String @uppercase
    email:String    
}

#Directive Declarations
directive  @uppercase on FIELD_DEFINITION

type Query {
    users:[User]
}

`
const USERS = [{
    id: 1,
    name: 'subramaian',
    email: 'subu@gmail.com'
},
{
    id: 2,
    name: 'murugan',
    email: 'murugan@gmail.com'
},
{
    id: 3,
    name: 'geetha',
    email: 'geetha@gmail.com',
},

]

//Directive logic 

function uppercaseDirectiveTransformer(schema, directiveName) {
    return mapSchema(schema, {
        //Logic
        [MapperKind.OBJECT_FIELD]: (filedConfig) => {
            //Check whether this field has the specificed directive 
            const uppercaseDirective = getDirective(schema, filedConfig, directiveName)
                ?.[0];
            if (uppercaseDirective) {
                //Get fields orginal resolver
                const { resolve = defaultFieldResolver } = filedConfig
                //Replace the original Resolver with a function that calls
                //the orginal resolver, then converts its result to upper case
                filedConfig.resolve = async function (source, args, ctx, info) {
                    const result = await resolve(source, args, ctx, info)
                    if (typeof result === 'string') {
                        //actual logic
                        return result.toUpperCase()
                    }
                    return result
                }
            };
            return filedConfig;

        }
    })
}




//2.Biz logic for hello Query : Resolvers
const resolvers = {
    Query: {
        users() {
            return USERS
        }
    },
    //Mutation
    //Subscription
}

//schema creation
let schema = makeExecutableSchema({
    typeDefs,
    resolvers
})

//attach Directive Existing Schema
schema = uppercaseDirectiveTransformer(schema, 'uppercase')

//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    schema
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)


Client side:
query Users {
  users {
    name
    id
    email
  }
}
Response:
{
  "data": {
    "users": [
      {
        "name": "SUBRAMAIAN",
        "id": "1",
        "email": "subu@gmail.com"
      },
      {
        "name": "MURUGAN",
        "id": "2",
        "email": "murugan@gmail.com"
      },
      {
        "name": "GEETHA",
        "id": "3",
        "email": "geetha@gmail.com"
      }
    ]
  }
}
.....................................................................................
		  Schema Definitions into a separate File
.....................................................................................

Your-App
  |
  src
   |
   index.ts
 schema.graphql

...
eg:
schema.graphql

type Query {
    hello:String
}

src/index.ts
    import { ApolloServer } from "@apollo/server"
    import { startStandaloneServer } from '@apollo/server/standalone'
    import { readFileSync } from "fs"

    const typeDefs = readFileSync("./schema.graphql", { encoding: 'utf-8' })

    //2.Biz logic for hello Query : Resolvers
    const resolvers = {
        Query: {
            hello() {
                return "Hello Graphql"
            }
        },
        //Mutation
        //Subscription
    }
    //3.We need to deploy the schema and bind with resolver 
    const server = new ApolloServer({
        typeDefs: typeDefs,
        resolvers: resolvers
    })

    //4.Start web server (Express.js)
    const { url } = await startStandaloneServer(server, {
        listen: {
            port: 4000
        }
    })
    console.log(`Apollo Server is Ready ${url}`)

.....................................................................................
			 How to isloate resolvers
....................................................................................

src
 |
resolvers.js


export const resolvers = {
    Query: {
        hello() {
            return "Hello Graphql"
        }
    },
    
}

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { readFileSync } from "fs"
import { resolvers } from "./resolvers.js"



const typeDefs = readFileSync("./schema.graphql", { encoding: 'utf-8' })
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)
....................................................................................
			Multiple Resolvers
....................................................................................

src
 |
 resolver.hello.ts
 resolver.hai.ts


resolver.hello.ts
export const helloResolver = {
    Query: {
        hello() {
            return "Hello Graphql"
        }
    },
    
}

resolver.hai.ts
export const HaiResolver = {
    Query: {
        hai() {
            return "Hai Graphql"
        }
    },
    
}

index.ts
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { readFileSync } from "fs"
import { helloResolver } from "./resolvers.hello.js"
import { HaiResolver } from "./resolver.hai.js"


const typeDefs = readFileSync("./schema.graphql", { encoding: 'utf-8' })

//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: [helloResolver, HaiResolver]
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready ${url}`)
....................................................................................
			 Coding Standards
...................................................................................

Your-App
  |
  src
   |
   index.ts  //main file
  users
    |
    users.resolver.ts
    users.datasource.db.ts  
    users.datasource.rest.ts
  customers
  posts
|
schema.graphql


eg:

Your-App
 |
schema.graphql
type User {
    id:ID!
    name:String 
    city:String
}
type Query {
    hello:String
    hai:String
    users:[User!]!
}


Your-App
 |
src
 |
 users
  |
  users.resolver
export const UserResolver = {
    Query: {
        users(parent, args, ctx, info) {
            return ctx.dataSources.usersAPI.findAll()
        }
    }

}


Your-App
 |
src
 |
 users
  |
user.datasource.ts

export class UserDataSource {
    constructor() {

    }
    findAll() {
        return [{ id: 1, name: 'subramanian', city: 'coimbatore' }]
    }
}


Your-App
 |
src
 |
 index.ts
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { readFileSync } from "fs"
import { UserResolver } from './users/users.resolver.js'
import { UserDataSource } from "./users/users.datasource.js"

const typeDefs = readFileSync("./schema.graphql", { encoding: 'utf-8' })


//Context Type:Type script syntax to have strong typing
interface MyContext {
    dataSources: {
        usersAPI: UserDataSource
    }
}
//3.We need to deploy the schema and bind with resolver 
const server = new ApolloServer<MyContext>({
    typeDefs: typeDefs,
    resolvers: [UserResolver]
})

//4.Start web server (Express.js)
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    },
    context: async (obj) => {
        return {
            dataSources: {
                usersAPI: new UserDataSource()
            }
        }
    }
})
console.log(`Apollo Server is Ready ${url}`)
.....................................................................................
			 Subscriptions
.....................................................................................

Ways of sending data from one place called source to another place destination.

1.Non Streaming way
  -if you ask the data from source, it will return the entire data in one short
 for eg, source returns list of customers which contains 100 records.
 100 records will be returned in one short.

2.Streaming way
  -if you ask the data from source, it will return one by one - step by step
   record by record.
  Client----asks---------->data
    <---data...................
    <---data
   etc..

How to enable Streaming?

 There are number of ways to implement streaming 

Reactive Programming:
 It is one of the most popular pattern to stream data.
 Way of sending and receiving data in async way with "Streaming"

Streaming:
  Data in flow  / Data flow

Stream Processing: 
  While you send and receive data, you can process the data like transformation,filtering,merging,mapping etc...
 Provides resilience features such as retry,fallback....

Subscriptions are similar to reactive Streams... if you want to stream data in graphql "Subscriptions Can be Used".

ApolloGraphql does not provide direct implementation on subscription,we have to enable through different dependency....

npm i graphql-ws ws @graphql-tools/schema
  

eg:
import { ApolloServer } from '@apollo/server';
import { expressMiddleware } from '@apollo/server/express4';
import { ApolloServerPluginDrainHttpServer } from '@apollo/server/plugin/drainHttpServer';
import express from 'express';
import { createServer } from 'http';
import { makeExecutableSchema } from '@graphql-tools/schema';
import { WebSocketServer } from 'ws';
import { useServer } from 'graphql-ws/lib/use/ws';
import { PubSub } from 'graphql-subscriptions';
import bodyParser from 'body-parser';
import cors from 'cors';

const PORT = 4000;
const pubsub = new PubSub();

// Schema definition
const typeDefs = `#graphql
  type Query {
    currentNumber: Int
  }

  type Subscription {
    numberIncremented: Int
  }
`;

// In the background, increment a number every second and notify subscribers when it changes.
let currentNumber = 0;
function incrementNumber() {
  currentNumber++;
  pubsub.publish('NUMBER_INCREMENTED', { numberIncremented: currentNumber });
  setTimeout(incrementNumber, 1000);
}

// Resolver map
const resolvers = {
  Query: {
    currentNumber() {
      return currentNumber;
    },
  },
  Subscription: {
    numberIncremented: {
      subscribe: () => pubsub.asyncIterator(['NUMBER_INCREMENTED']),
    },
  },
};

// Create schema, which will be used separately by ApolloServer and
// the WebSocket server.
const schema = makeExecutableSchema({ typeDefs, resolvers });

// Create an Express app and HTTP server; we will attach the WebSocket
// server and the ApolloServer to this HTTP server.
const app = express();
const httpServer = createServer(app);

// Set up WebSocket server.
const wsServer = new WebSocketServer({
  server: httpServer,
  path: '/graphql',
});
const serverCleanup = useServer({ schema }, wsServer);

// Set up ApolloServer.
const server = new ApolloServer({
  schema,
  plugins: [
    // Proper shutdown for the HTTP server.
    ApolloServerPluginDrainHttpServer({ httpServer }),

    // Proper shutdown for the WebSocket server.
    {
      async serverWillStart() {
        return {
          async drainServer() {
            await serverCleanup.dispose();
          },
        };
      },
    },
  ],
});

await server.start();
app.use('/graphql', cors<cors.CorsRequest>(), bodyParser.json(), expressMiddleware(server));

// Now that our HTTP server is fully set up, actually listen.
httpServer.listen(PORT, () => {
  console.log(`🚀 Query endpoint ready at http://localhost:${PORT}/graphql`);
  console.log(`🚀 Subscription endpoint ready at ws://localhost:${PORT}/graphql`);
});

// Start incrementing
incrementNumber();


Testing:
http://localhost:4000/graphql

Client side:

subscription {
  numberIncremented
}

Response:

{
  "data": {
    "numberIncremented": 236
  }
}

// Response received at 19:37:12
{
  "data": {
    "numberIncremented": 235
}
.....................................................................................



























































































































































